/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "oauth.h"
#include "server_functions.h"

void
oauth_1(char *host, char *userId, char *action, char *resource)
{

	CLIENT *clnt;
	char * *req_code;
	requestTokenAcces  request_authorization_token_1_arg;
	char * *approve_request_token;
	char * *result_4;
	char * approve_request_token_1_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, OAUTH, OAUTH_V1, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	// avem 2 cazuri => caz de request sau caz de actiune/operatie

	if (strncmp(action, "REQUEST", strlen(action)) == 0) {
		req_code = request_authorization_1(&userId, clnt);

		if (req_code == (char **) NULL) {
			clnt_perror (clnt, "call failed");
		}

		// daca userul nu exista intoarcem eroare, daca exista continuam generarile
		if (req_code != NULL && strncmp(*req_code, "USER_NOT_FOUND", strlen("USER_NOT_FOUND")) == 0) {
			printf("USER_NOT_FOUND\n");
		} else if (req_code != NULL) {

			approve_request_token = approve_request_token_1(&(*req_code), clnt);

			// verificam daca tokenul de request a fost semnat sau nu bine
			if (check_signature(*approve_request_token, *req_code) == 0) {
				// daca nu este semnat bine
				printf("REQUEST_DENIED\n");

			} else {
				// daca este semnat bine continuam, cu generarea tokenului de acces
				// si a tokenului de refresh daca este nevoie
				request_authorization_token_1_arg.user_id = malloc(15 * sizeof(char));
				request_authorization_token_1_arg.token = malloc(15 * sizeof(char));
				strcpy(request_authorization_token_1_arg.token, *req_code);
				strcpy(request_authorization_token_1_arg.user_id, userId);

				if (resource[0] == '0') {
					request_authorization_token_1_arg.type = 0;
				} else if (resource[0] == '1') {
					request_authorization_token_1_arg.type = 1;
				}

				returnRequestTokenAcces *acc_token = request_authorization_token_1(&request_authorization_token_1_arg, clnt);

				if (acc_token == (returnRequestTokenAcces *) NULL) {
					clnt_perror (clnt, "call failed");
				}

				// facem afisare diferentiata in functie de tipul requestului (cu refresh sau fara)
				if (request_authorization_token_1_arg.type == 0) {
					printf("%s -> %s\n", *req_code, acc_token->tokenAcces);
				} else {
					printf("%s -> %s,%s\n", *req_code, acc_token->tokenAcces, acc_token->tokenRegen);
				}

			}
		}

		fflush(stdout);
		
	} else {
		// tragem cateva informatii despre user de pe server pentru a face rost de acces token
		gatAndHandelTtl *user = get_acces_token_and_handel_ttl_1(&userId, clnt);

		enum AuthResult  *result_3;
		validateDelegatedAction  validate_delegated_action_1_arg;
		
		validate_delegated_action_1_arg.token = malloc(15 * sizeof(char));
		validate_delegated_action_1_arg.tipOperatie = malloc(5 * sizeof(char));
		validate_delegated_action_1_arg.resursa = malloc(100 * sizeof(char));

		strcpy(validate_delegated_action_1_arg.token, user->token);
		strcpy(validate_delegated_action_1_arg.tipOperatie, action);
		strcpy(validate_delegated_action_1_arg.resursa, resource);

		result_3 = validate_delegated_action_1(&validate_delegated_action_1_arg, clnt);
		
		if (result_3 == (enum AuthResult *) NULL) {
			clnt_perror (clnt, "call failed");
		}

		// afisez raspuns in functie de ce enum AuthResult imi returneaza functia de 
		// delegate a serverului
		if (*result_3 == PERMISSION_GRANTED) {
			printf("PERMISSION_GRANTED\n");
		} else if (*result_3 == OPERATION_NOT_PERMITTED) {
			printf("OPERATION_NOT_PERMITTED\n");
		} else if (*result_3 == RESOURCE_NOT_FOUND) {
			printf("RESOURCE_NOT_FOUND\n");
		} else if (*result_3 == TOKEN_EXPIRED) {
			printf("TOKEN_EXPIRED\n");
		} else {
			printf("PERMISSION_DENIED\n");
		}

		fflush(stdout);

	
	}



#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}


int
main (int argc, char *argv[])
{
	char *addr_server;
	char *op_file;

	if (argc < 2) {
		printf ("usage: %s server_host\n", argv[0]);
		exit (1);
	}

	addr_server = argv[1];
	op_file = argv[2];

	FILE *file = fopen(op_file, "r");
    if (file == NULL) {
        perror("Eroare la deschiderea fiÈ™ierului");
        exit(EXIT_FAILURE);
    }

	char line[100];

	while (!feof(file)) {
        if (fgets(line, sizeof(line), file) != NULL) {

			// elimin '\n' din linie apoi imi iau fiecare element din ea
			char *simple_line = strtok(line, "\n");
			char *token = strtok(simple_line, ",");
			char user_id[16];
			char action[10];
			char resource[30];

			if (token != NULL) {
				strncpy(user_id, token, 16);
			}

			token = strtok(NULL, ",");
			if (token != NULL) {
				strcpy(action, token);
			}

			token = strtok(NULL, ",");
			if (token != NULL) {
				strcpy(resource, token);
			}

			oauth_1("localhost", user_id, action, resource);
        }
    }

	fclose(file);

exit (0);
}
