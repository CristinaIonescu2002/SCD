/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "oauth.h"
#include "server_functions.h"
#include "token.h"

// funtcie pentru generarea tokenului de autorizare
char **
request_authorization_1_svc(char **argp, struct svc_req *rqstp)
{
	static char *result; 
	char *user_id = *argp;

	printf("BEGIN %s AUTHZ\n", user_id);
	fflush(stdout);

	node_users_main *aux = users_main_list->head;
	int maxLen = users_main_list->len;
	int cnt = 0;

	// cautam prin "baza de date" sa vedem daca gasim userul
    while (cnt < maxLen) {

		// cand gasim un user, generam tokenul, il retinem pe user si ii dam 
		// ce aprobari are daca mai exista aprobari valabile
		if (strcmp(user_id, aux->userId) == 0) {

			char *token = generate_access_token(user_id);
			strncpy(aux->auth_token, token, strlen(token));

			if (Counter_Resources_Taken + 1 > nr_resources) {
				aux->approval = -1;
			} else {
				aux->approval = Counter_Resources_Taken;
			}

			Counter_Resources_Taken++;


			result = token;
			return &result;
		}

        aux = aux->next;
		cnt++;
    }

	result = "USER_NOT_FOUND";
	Counter_Resources_Taken++;

	return &result;
}

// functie pentru generarea tokenurilor de acces si refresh
returnRequestTokenAcces *
request_authorization_token_1_svc(requestTokenAcces *argp, struct svc_req *rqstp)
{
	requestTokenAcces str_userId_token = *argp;
	static returnRequestTokenAcces result;

	result.tokenAcces = malloc(15 * sizeof(char));
	result.tokenRegen = malloc(15 * sizeof(char));

	char *token = generate_access_token(str_userId_token.token);
	strcpy(result.tokenAcces, token);

	printf("  AccessToken = %s\n", result.tokenAcces);
	
	node_users_main *node = get_node(str_userId_token.user_id);

	// daca nu e request de refresh, tokenul de refresh va fi vid
	if (str_userId_token.type == 0) {
		strcpy(result.tokenRegen, "");

	} else if (str_userId_token.type == 1) {
		// generare token de refresh

		char *refresh = generate_access_token(result.tokenAcces);
		strcpy(result.tokenRegen, refresh);

		printf("  RefreshToken = %s\n", result.tokenRegen);
	}

	node->has_refresh = str_userId_token.type;
	node->ttl = TTL;
	strcpy(node->acces_token, result.tokenAcces);
	strcpy(node->refresh_token, result.tokenRegen);

	fflush(stdout);

	return &result;
}

// functie pentru executarea actiunilor 
enum AuthResult *
validate_delegated_action_1_svc(validateDelegatedAction *argp, struct svc_req *rqstp)
{
	static enum AuthResult  result;
	validateDelegatedAction arg = *argp;

	node_users_main *user = get_node_with_acc_token(arg.token);
	int resourceExists = check_resources(arg.resursa);

	// daca ttl este -1 inseamna ca userul nu are token de acces
	if (user->ttl == -1) {
		result = PERMISSION_DENIED;

		printf("%s (%s,%s,%s,%d)\n", "DENY", arg.tipOperatie, arg.resursa, user->acces_token, 0);
		fflush(stdout);

		return &result;
	}
	else if (resourceExists == 1) {
		// verifica daca resursa specificata nu exista

		result = RESOURCE_NOT_FOUND;
		user->ttl = user->ttl - 1;
	} 
	else if (user->ttl == 0 && user->has_refresh == 0) {
		// verifica daca tokenul de acces a expirat (caz doar pt cand nu are refresh)
		result = TOKEN_EXPIRED;

		strcpy(user->acces_token, "");
	} 
	else {

		// doar daca avem request cu refresh (regeneram tokenul de acces si refresh)
		if (user->ttl == 0 && user->has_refresh == 1) {

			char *newAccesToken = generate_access_token(user->refresh_token);
			strcpy(user->acces_token, newAccesToken);
			user->ttl = TTL;

			char *newRefreshToken = generate_access_token(user->acces_token);
			strcpy(user->refresh_token, newRefreshToken);

			printf("BEGIN %s AUTHZ REFRESH\n", user->userId);
			printf("  AccessToken = %s\n", user->acces_token);
			printf("  RefreshToken = %s\n", user->refresh_token);
			fflush(stdout);
		}

		// daca userul nu are niciun fel de drepturi puse
		if (user->approval < 0 && user->approval >= nr_resources) {
			result = PERMISSION_DENIED;
		} else {
			// luam lista de dreptruri pe care userul le are
			resources_node_t *node = approvals_list[user->approval]->head;

			while (node != NULL) {

				// cautam resursa dorita
				if (strcmp(node->resName, arg.resursa) == 0) {

					char op;

					// luam tipul de operatie care se doreste
					if (strcmp(arg.tipOperatie, "READ") == 0) {
						op = 'R';
					} else if (strcmp(arg.tipOperatie, "DELETE") == 0) {
						op = 'D';
					} else if (strcmp(arg.tipOperatie, "EXECUTE") == 0) {
						op = 'X';
					} else if (strcmp(arg.tipOperatie, "MODIFY") == 0) {
						op = 'M';
					} else if (strcmp(arg.tipOperatie, "INSERT") == 0) {
						op = 'I';
					} else {
						op ='-';
					}

					for (int i=0; i<strlen(node->op); i++) {
						// cautam operatia dorita in lista de operatii posibile pe care le are userul pe resursa
						if (op == node->op[i]) {
							result = PERMISSION_GRANTED;
							user->ttl = user->ttl - 1;

							printf("%s (%s,%s,%s,%d)\n", "PERMIT", arg.tipOperatie, arg.resursa, user->acces_token, user->ttl);
							fflush(stdout);

							return &result;
						}
					}
				}

				node = node->next;
			}

			// daca s-a ajuns aici inseamna ca nu are dreptul necesar pentru a face operatia
			result = OPERATION_NOT_PERMITTED;
			user->ttl = user->ttl - 1;

			printf("%s (%s,%s,%s,%d)\n", "DENY", arg.tipOperatie, arg.resursa, user->acces_token, user->ttl);
			fflush(stdout);

			return &result;
		}
	}

	printf("%s (%s,%s,%s,%d)\n", "DENY", arg.tipOperatie, arg.resursa, user->acces_token, user->ttl);
	fflush(stdout);

	return &result;
}

// functie pentru aprobarea tokenului de autorizare
char **
approve_request_token_1_svc(char **argp, struct svc_req *rqstp)
{
	static char *result;
	char *authorize_token = *argp;

	node_users_main *aux = users_main_list->head;

	printf("  RequestToken = %s\n", authorize_token);

    while (aux != NULL) {

		// cautam userul care are tokenul respectiv
		if (strcmp(authorize_token, aux->auth_token) == 0) {

			// verificam daca are permisiunile necesare
			if (check_permission(aux->userId) == 0) {

				// modificam putin tokenul pentru a-l valida
				char *modified_token = strdup(authorize_token);
				modified_token[strlen(modified_token) - 1] = 'z' - modified_token[strlen(modified_token) - 1];

				result = malloc(strlen(modified_token) * sizeof(char *));
				strncpy(result, modified_token, strlen(modified_token));

				return &result;
			}

		}

        aux = aux->next;
    }

	result = malloc(strlen(authorize_token) * sizeof(char *));
	strncpy(result, authorize_token, strlen(authorize_token));

	return &result;
}

// functie pentru a face rost de tokenul de acces si ttl pentru user
gatAndHandelTtl *
get_acces_token_and_handel_ttl_1_svc(char **argp, struct svc_req *rqstp)
{
	static gatAndHandelTtl result;
	char *user_id = *argp;

	result.token = malloc(15 * sizeof(char));

	node_users_main *aux = users_main_list->head;

    while (aux != NULL) {

		if (strcmp(user_id, aux->userId) == 0) {

			result.ttl = aux->ttl;
			strcpy(result.token, aux->acces_token);

			return &result;
		}

        aux = aux->next;
    }

	return &result;
}

// am adaugat functa asta pentru ca credeam ca voi avea nevoie de ea
// dar nu a mai fost nevoie (nu am mai eliminat-o pentru ca nu am
// mai avut timp)
int *
increase_count_1_svc(void *argp, struct svc_req *rqstp)
{
	static int result = 0;

	// Counter_Resources_Taken++;

	return &result;
}
